from flask import Flask, escape, request, make_response
import os
import requests
from Crypto.Cipher import AES
import urllib
import base64
from datetime import datetime, timedelta

# These variables should be configured as per your own parameters for each application in your API Gateway Maintanence portal.
# They can be configured using the .env file

# Token as generated by API Gateway
tokenKey=os.environ['TOKEN_KEY']
# Specified upon API setup in TASS API Gateway Maintenance program.
appCode=os.environ['APPCODE']
# TASS company to work with (see top right of TASS.web).
companyCode=os.environ['COMPANY_CODE']
# TASS API version.
apiVersion=os.environ['API_VERSION']
# TASS API method.
method=os.environ['METHOD']
# TASS API endpoint.
endPoint=os.environ['ENDPOINT']
# Parameters for passthrough - varies based on method.
parameters = "{\"start_date\":\"01/01/2021\",\"end_date\":\"01/01/2022\"}"
# Name of calendar
name=os.environ['NAME']


def getEncryptedToken(token, params):
    #decode the token from b64 format
    decoded = base64.b64decode(token)
    plaintext = params
    #put ECB padding in place for plaintext
    length = 16 - (len(plaintext) % 16)
    plaintext += chr(length)*length
    rijndael = AES.new(decoded, AES.MODE_ECB)
    #encrypt the plaintext
    ciphertext = rijndael.encrypt(plaintext)
    ciphertext = base64.b64encode(ciphertext)
    return ciphertext


def getDecryptedToken(token, encrypted):
    #decode from b64 for both the token and the encrypted data
    decoded = base64.b64decode(token)
    encoded = base64.b64decode(encrypted)
    decoder = AES.new(decoded, AES.MODE_ECB)
    #decrypt the data
    output = decoder.decrypt(encoded)
    return output


def getURLRequest(endPoint, method, appCode, companyCode, apiVersion, parameters, tokenKey):
    encrypted = getEncryptedToken(tokenKey, parameters)
    requestDict = {"method": method, "appcode": appCode, "company": companyCode, "v": apiVersion, "token": encrypted}
    requestStr = urllib.parse.urlencode(requestDict)
    URLString = endPoint + '?' + requestStr
    return URLString


def create_calendar():
    url = getURLRequest(endPoint, method, appCode, companyCode, apiVersion, parameters, tokenKey)
    # Make a get request
    content = requests.get(url=url).json()

    ical = "BEGIN:VCALENDAR\r\n"
    ical += "VERSION:2.0\r\n"
    ical += "PRODID:-//" + name + "//EN\r\n"
    for event in content["events"]:
        # Event name and description
        _id = str(event["id"])
        _summary = event["title"]
        _description = event["description"]

        # Event categories
        _category = event["cat_desc"]

        # Time and date settings
        _stamp = datetime.strptime(event["start"], "%Y-%m-%d %H:%M:%S").strftime("%Y%m%dT%H%M%S")
        _start = datetime.strptime(event["start"], "%Y-%m-%d %H:%M:%S").strftime("%Y%m%dT%H%M%S")
        _end = datetime.strptime(event["end"], "%Y-%m-%d %H:%M:%S").strftime("%Y%m%dT%H%M%S")
        _all_day = bool(event["all_day"])

        # Construct the ics file
        ical += "BEGIN:VEVENT\r\n"
        ical += "UID:" + _id + "\r\n"
        ical += "SUMMARY:" + _summary + "\r\n"
        ical += "DESCRIPTION:" + _description + "\r\n"
        ical += "CATEGORIES:" + _category + "\r\n"
        ical += "DTSTAMP:" + _stamp + "\r\n"

        # All day events require a different time/end format than normal events
        # This will change the format if an all day event is selected
        if _all_day:
            _start = datetime.strptime(_start, "%Y%m%dT%H%M%S")
            # All day events are triggered when the start date is set to midnight
            # and the end date is set to midnight the following day.
            # Therefore we need to add 1 to the start date when forming the end date.
            _end = _start + timedelta(days=1)
            _start = _start.strftime("%Y%m%d")
            _end = _end.strftime("%Y%m%d")

            ical += "DTSTART;VALUE=DATE:" + _start + "\r\n"
            ical += "DTEND;VALUE=DATE:" + _end + "\r\n"
        else:
            ical += "DTSTART:" + _start + "\r\n"
            ical += "DTEND:" + _end + "\r\n"

        ical += "END:VEVENT\r\n"


    ical += "END:VCALENDAR\r\n"
    return ical


app = Flask(__name__)

@app.route('/calendar.ics')
def calendar_ics():
    # Get the calendar
    _calendar = create_calendar()

    response = make_response(_calendar)
    response.headers["Content-Disposition"] = "attachment; filename=calendar.ics"
    response.headers["Content-type"] = "text/calendar; charset=UTF-8"
    return response

